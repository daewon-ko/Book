# 048번 불변문자열



### String은 왜 불변일까?

- **반대로 String이 불변이면 장점과 단점이 무엇일까?**

### 불변으로서의 장점

- 문자열 상수 풀 또는 캐시 풀

- **문자열 상수 풀**

  - 문자열 리터럴을 저장하는 메모리 내 특수한 영역

  ```java
  String x = "book";
  String y = "book";
  String z = "book";
  ```

  - **자바는 값이 “book”인 String 객체는 딱 하나만 생성**
  - 큰 따옴표 속 내용을 문자열 리터럴로 간주하고 ‘상수 풀’이라는 메모리에 저장
    - 문자열 리터럴 생성 → 자바는 문자열 상수풀을 검사하여 리터럴 존재 여부 확인
    - 리터럴이 없으면 새 문자열 객체를 문자열 상수풀에 생성 후 ‘변수 x’가 해당 객체를 가리키게함
    - 상수 풀 내에 리터럴이 있으면 새 변수(y,z)는 String 객체를 가리키게됨.
  - 문자열이 불변이면, 문자열 리터럴을 캐싱하여 힙메모리와 GC에 미치는 영향을 최소화하면서 애플리케이션에서 다수의 문자열을 사용할 수 있음
  - What IF) 문자열이 가변
    - → 문자열 리터럴 수정 시 변수 손상으로 이어질 수 있음
    - CF) String x = new String(”book”)처럼 생성하게 되면 x는 리터럴이 아니라, 일반 힙 메모리에 객체로서 저장됨.

- **보안**

  - 비밀번호, 이름, URL, 등 정보가 불변이면 고의로 참조를 수정하는 등의 보안위험으로 부터 안전

- **스레드 세이프**

  - 모든 불변 객체는 본질적으로 Thread Safe함.
  - 손상이나, 불일치 없이 다수의 스레드로 문자열을 공유 및 조작 가능

- **해시코드 캐싱**

  - String은 불변이므로 문자열을 생성한 이후에는 변경할 수 없다.
  - 따라서 문자열마다 캐싱하고 재사용할 수 있는 불변 해시코드가 존재한다.
  - → 문자열의 해시코드를 쓸때마다 다시 계산하지 않고 캐시에서 가져와 재사용할 수 있다는 뜻

  ```java
  String s = "hello";
  
  // 첫 번째 호출 → 해시코드 계산 후 캐싱
  int h1 = s.hashCode();
  
  // 이후 호출 → 계산하지 않고, 캐싱된 값 반환
  int h2 = s.hashCode();
  ```

  → 여러 스레드가 동시에 hashCode()를 호출해도, 누가 먼저 계산하든 상관없고 한 번 계산된 이후에는 모두 동일한 캐시된 값을 ‘읽기’만 하게됨.

  따라서 동기화 이슈에서 안전함.

  추가적으로, 캐싱을 하는 이유는?

  - 문자열이 길 수록 해시 계산 비용이 커짐.
  - Hash기반 자료구조(HashMap, HashSet) 등에서 String이 key값으로 사용된다고 할때, 매번 문자를 그때마다 해시계산하면 비효율적

- **클래스 로딩**

  - Class.forName(String className)
    - 메모리에 클래스 로딩 시의 메서드의 매개변수는 String
    - 즉, 클래스명 그 자체는 ‘로딩 과정’에서 변하지 않음을 확정할 수 있음

------

### 문자열 불변의 단점

- 확장 불가
  - String을 확장이 불가함.
    - Apache Common Lang, Spring Framework의 StringUtils등을 활용 가능
- OOM 발생 가능성
  - 문자열 상수 풀은 상대적으로 다른 곳에 비해 메모리 영역이 작음
- 민감 데이터가 메모리에 장기간 머뭄
  - 다른 메모리 영역에 비해서 GC는 다른 빈도로 문자열 상수풀을 방문
  - 따라서 민감한 데이터가 문자열 상수 풀에 오래 머무를 수 있음
  - 따라서, 정말 민감한 데이터라면 String보다는 char[]에 저장이 유리할 수 있음