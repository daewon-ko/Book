# Chapter10 프로세스와 스레드

### 프로세스

* 포그라운드 프로세스
  * 사용자가 보는 앞에서 실행되는 프로세스
* 백그라운드 프로세스
  * 사용자가 보지 못하는 곳에서 실행되는 프로세스
  * 백그라운드 프로세스 중 사용자와 상호작용하지 않고 본인의 일을 묵묵히 하는 프로세스
    * 데몬(UNIX), 서비스(윈도우)

### PCB(프로세스 제어 블록)

* OS는 빠르게 번갈아 수행되는 프로세스의 실행순서를 관리하는데, <b>PCB</b>를 이용
* PCB는 각 프로세스별로 커널영역에 생성된다. 
* PCB
  * 프로세스와 관련된 정보를 저장하는 자료구조
  * 커널영역에 생성
  * OS는 PCB로 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 판단
  * 프로세스의 생명주기와 동일(프로세스 생성시에 탄생하고 프로세스 소멸 시에 삭제된다.)

하단은 PCB에 포함되는 정보들이다.

	1. PID

    - 프로세스 식별위한 고유번호

	2. 레지스터값

    - Context-Switching 시에 각 프로세스의 레지스터 값이 저장된다. 

    - CF) 레지스터 값이란 CPU에서 현재 실행중인 프로세스의 주소값을 의미하는 Program Counter값 뿐 아니라 

      다양한 값들을 포괄한다.

    - 스택 포인터(Stack Pointer), 베이스 레지스터(Base Register), 상태 레지스터(Status Register) 와 같은 레지스터 값들이 있다. 

3. 프로세스 상태
   - 현재 프로세스가 I/O장치를 사용하기 위해 대기 중인지 혹은 CPU를 점유하기 위해 대기 중인지 등의 상태가 기록
4. CPU 스케줄링 정보
   - 언제 어떤 순서로 CPU를 할당받을 것인가
5. 메모리 관리정보
   - 프로세스가 어느 주소에 저장되어 있는지 (즉 메모리의 어느 곳에 저장되어 있는지)에 관한 정보
   - 베이스 레지스터, 한계 레지스터값, 페이지 테이블 정보 등이 기재
6. 사용파일과 입출력장치목록
   - 프로세스가 실행 과정에서 특정 입출력장치 또는 파일(I/O작업)를 사용하면 PCB에 해당 내용이 저장된다. 

### Context-Switching(문맥 교환)

* 프로세스가 CPU를 점유하다가 하드웨어/소프트웨어 인터럽트가 발생하여 CPU의 점유권을 다른 프로세스에게 이양하는 것

* 프로세스는 각종 레지스터 값, 메모리 정보 등의 중간정보를 백업한다. 

  * ##### -> '문맥'

  * 프로세스 문맥은 곧 PCB라고 할 수 있다. 

  * OS는 인터럽트가 발생하면 PCB에 문맥을 백업한다.

### 프로세스의 메모리 영역

* 사용자영역

  * 코드영역

    * 기계어로 이루어진 명령어
    * Data가 아닌 CPU실행명령어가 담겨있기에 쓰기 금지. 즉 Read Only

  * 데이터영역

    * 전역변수 저장

    -> 코드, 데이터영역은 크기가 변하지 않는다. 

  * 힙영역

    * 사용자 할당영역
      * 자바의 인스턴스변수, 객체의 참조변수 등이 해당

  * 스택영역

    * 데이터를 일시적으로 저장
    * 매개변수, 지역변수 등이 저장

CF)

```java
public static void main(String [] args){
	int a = 10;
}

class A {
 int b = 10;
}

```

자바 언어의 예시에서 a변수는 main 메서드의 지역변수이므로 스택영역에 저장되고, b 변수는 A라는 클래스의 인스턴스 변수이므로 힙 영역에 저장된다. 

​	-> 힙영역과 스택영역은 실시간으로 크기가 변한다. 따라서 동적할당역이라고 함. 

<img src="https://github.com/daewon-ko/Book/assets/105340285/10b731dd-7b4d-48be-be8c-6b6bed4d3553" alt="image-20240505205249059" style="zoom: 33%;" />

### 프로세스 

* 생성
  * 메모리에 막 적재되어 PCB를 할당
* 준비
  * CPU할당을 받기위해 대기중인 상태
* 실행
  * CPU를 할당받아 실행중인 상태
  * 타이머 인터럽트가 발생하면 다시 준비가 되고, I/O사용시 입출력장치의 작업이 끝날때까지 대기상태가 됨
* 대기
  * I/O등의 작업이 끝날때까지 대기중인 상태
  * CF) I/O등의 작업으로 해당 프로세스가 blocked되면 I/O 작업이 CPU의 연산속도보다 느리므로 OS는 CPU를 다른 프로세스에 할당
* 종료
  * 프로세스가 종료 / OS는 PCB와 프로세스가 사용한 메모리를 삭제

### 프로세스 계층구조

* 프로세스는 고유식별번호가 존재(PID)
* 부모 프로세스 -> 자식 프로세스 -> 자식 프로세스 -> ... -> 자손 프로세스

### 프로세스 생성 기법

* fork() -> 자식 프로세스 생성
  * 자식 프로세스는 부모 프로세스의 자원을 상속받지만 PID, 메모리 위치 등은 다르다. 
* exec() -> 생성된 자식 프로세스가 자신의 메모리 공간을 다르프로그램으로 교체
  * 코드영역, 데이터 영역이 실행할 프로그램으로 교체되고 나머지 영역은 초기화 된다.
* 두 방식 모두 System Call을 호출
* CF) 부모프로세스가 자식 프로세스를 fork()한 후 누구도 exec()를 호출하지 않는 경우도 존재
  * 해당 경우는 부모와 자식이 같은 코드를 병행하여 실행하는 프로세스

### 스레드

* 경량 프로세스(하나의 프로세스는 여러 개의 스레드를 가질 수 있다는 차원에서) 

* ##### 프로세스를 구성하는 실행 /흐름단위 

### 프로세스와 스레드

* 스레드는 프로세스 내에서 각기 다른 스레드ID, 프로그램 카운터와 같은 레지스터 값, 스택으로 구성되며 그 외의 프로세스의 자원을 공유하며 실행된다. 
* 그 외에 코드, 데이터, 힙 등은 공유
* 최근의 많은 OS는 CPU에 처리할 작업을 프로세스가 아닌 스레드 단위로 전달.

### 멀티프로세스와 멀티스레드

* 동일한 작업을 멀티 프로세스와 멀티스레드로 수행하는 것은 어떤 차이가 있을까?
  * 프로세스끼리는 <b>'기본적으로'</b> 자원을 공유하지 않지만 스레드끼리는 같은 프로세스 내의 자원을 공유
    * CF) '기본적으로' 프로세스끼리 자원을 공유하지 않는다는 것이지 IPC와 같은 방식도 존재
  * 프로세스를 fork()하여 같은 작업을 하는 프로세스를 생성하면 코드, 데이터, 힙을 비롯한 모든 자원이 복제
  * 스레드는 스레드 ID, 프로그램 카운터, 스택영역을 제외한 나머지 모두를 같은 프로세스 내에서 공유
  * 즉 스레드는 프로세스의 자원을 공유하기에 협력과 통신에 유리
  * 그러나, 멀티스레드는 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있다. 

### IPC(Inter Process Communication)

* 프로세스끼리 자원을 공유하고 데이터를 주고받는 방식

* 서로 공유하는 메모리 영역을 두어 데이터를 주고받을 수 있다. 

  * 해당 메모리 영역을 '공유메모리'라고 함.

* 또한 소켓, 파이프 등을 통해 통신 가능

  (해당 개념의 심화버전은 Tech-Interview 통해 Deep Dive 예정)